<!DOCTYPE html>
<html>
<head>
    <title>⚡ REAL-TIME UNIVERSE SIMULATION ⚡</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000;
            cursor: grab;
        }
        canvas { 
            display: block; 
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #0ff;
            font-family: 'Arial', sans-serif;
            text-shadow: 0 0 10px #00f7ff;
            z-index: 100;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="ui">
        <h1>⚡ QUANTUM UNIVERSE SIMULATOR ⚡</h1>
        <p id="stats">Loading cosmic data...</p>
    </div>
    <div id="controls">
        <button id="bigBang">Trigger Big Bang</button>
        <button id="blackHole">Create Black Hole</button>
        <button id="expand">Toggle Expansion</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script>
        // ====== ULTRA-REALISTIC UNIVERSE ====== //
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // ====== COSMIC BACKGROUND ====== //
        const universeGeometry = new THREE.SphereGeometry(50000, 60, 60);
        const universeTexture = new THREE.TextureLoader().load('https://images.unsplash.com/photo-1462331940025-496dfbfc7564?ixlib=rb-1.2.1&auto=format&fit=crop&w=2048&q=80');
        const universeMaterial = new THREE.MeshBasicMaterial({ 
            map: universeTexture,
            side: THREE.BackSide
        });
        const universe = new THREE.Mesh(universeGeometry, universeMaterial);
        scene.add(universe);

        // ====== REALISTIC GALAXY ====== //
        function createSpiralGalaxy(arms = 4, starsCount = 5000) {
            const galaxyGeometry = new THREE.BufferGeometry();
            const galaxyMaterial = new THREE.PointsMaterial({
                size: 0.1,
                color: 0xffffff,
                transparent: true,
                opacity: 0.8
            });
            
            const positions = [];
            const colors = [];
            
            for (let i = 0; i < starsCount; i++) {
                const arm = Math.floor(Math.random() * arms);
                const distance = Math.random() * 50 + Math.pow(Math.random(), 3) * 100;
                const angle = (arm * (Math.PI * 2 / arms)) + (Math.random() * 0.2) + (distance * 0.1);
                
                positions.push(
                    Math.cos(angle) * distance,
                    (Math.random() - 0.5) * 10,
                    Math.sin(angle) * distance
                );
                
                // Color based on star type
                const starType = Math.random();
                if (starType < 0.7) colors.push(0.9, 0.9, 1.0); // Blue-white
                else if (starType < 0.9) colors.push(1.0, 0.8, 0.5); // Yellow
                else colors.push(1.0, 0.5, 0.5); // Red
            }
            
            galaxyGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            galaxyGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const galaxy = new THREE.Points(galaxyGeometry, galaxyMaterial);
            galaxy.rotation.x = Math.PI / 4;
            return galaxy;
        }

        const milkyWay = createSpiralGalaxy();
        scene.add(milkyWay);

        // ====== REAL SOLAR SYSTEM ====== //
        function createPlanet(name, size, distance, color, textureUrl = null) {
            const geometry = new THREE.SphereGeometry(size, 32, 32);
            let material;
            
            if (textureUrl) {
                const texture = new THREE.TextureLoader().load(textureUrl);
                material = new THREE.MeshStandardMaterial({ map: texture });
            } else {
                material = new THREE.MeshStandardMaterial({ color });
            }
            
            const planet = new THREE.Mesh(geometry, material);
            
            // Add orbital path
            const orbitGeometry = new THREE.BufferGeometry();
            const orbitPoints = [];
            for (let i = 0; i <= 64; i++) {
                const theta = (i / 64) * Math.PI * 2;
                orbitPoints.push(
                    Math.cos(theta) * distance,
                    0,
                    Math.sin(theta) * distance
                );
            }
            orbitGeometry.setFromPoints(orbitPoints);
            const orbitMaterial = new THREE.LineBasicMaterial({ color: 0x444444 });
            const orbit = new THREE.Line(orbitGeometry, orbitMaterial);
            
            // Add label
            const label = document.createElement('div');
            label.textContent = name;
            label.style.position = 'absolute';
            label.style.color = 'white';
            label.style.fontFamily = 'Arial';
            label.style.pointerEvents = 'none';
            document.body.appendChild(label);
            
            return { planet, orbit, label };
        }

        // Real planets with approximate sizes and distances
        const sun = createPlanet('Sun', 10, 0, 0xffff00, 'https://www.solarsystemscope.com/textures/download/2k_sun.jpg');
        const mercury = createPlanet('Mercury', 0.4, 15, 0xaaaaaa);
        const venus = createPlanet('Venus', 0.9, 20, 0xffaa66);
        const earth = createPlanet('Earth', 1, 25, 0x1a66ff, 'https://www.solarsystemscope.com/textures/download/2k_earth_daymap.jpg');
        const mars = createPlanet('Mars', 0.5, 30, 0xff3300);
        const jupiter = createPlanet('Jupiter', 5, 40, 0xffcc99, 'https://www.solarsystemscope.com/textures/download/2k_jupiter.jpg');
        const saturn = createPlanet('Saturn', 4, 50, 0xdddd77);
        const uranus = createPlanet('Uranus', 3, 60, 0x66aaff);
        const neptune = createPlanet('Neptune', 3, 70, 0x3333ff);
        
        scene.add(sun.planet);
        scene.add(mercury.planet, mercury.orbit);
        scene.add(venus.planet, venus.orbit);
        scene.add(earth.planet, earth.orbit);
        scene.add(mars.planet, mars.orbit);
        scene.add(jupiter.planet, jupiter.orbit);
        scene.add(saturn.planet, saturn.orbit);
        scene.add(uranus.planet, uranus.orbit);
        scene.add(neptune.planet, neptune.orbit);

        // ====== BLACK HOLE ====== //
        function createBlackHole(position) {
            const geometry = new THREE.SphereGeometry(3, 32, 32);
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec2 vUv;
                    
                    void main() {
                        vec2 uv = vUv * 2.0 - 1.0;
                        float dist = length(uv);
                        float angle = atan(uv.y, uv.x);
                        
                        // Black hole distortion
                        float warp = 0.1 / (dist + 0.1);
                        
                        // Accretion disk
                        float disk = smoothstep(0.5, 0.7, dist) * (1.0 - smoothstep(0.7, 1.0, dist));
                        vec3 color = mix(vec3(0.0), vec3(0.8, 0.3, 0.1), disk);
                        
                        // Time-based animation
                        color += 0.3 * sin(angle * 10.0 + time * 2.0) * disk;
                        
                        gl_FragColor = vec4(color, 1.0);
                    }
                `,
                side: THREE.DoubleSide
            });
            
            const blackHole = new THREE.Mesh(geometry, material);
            blackHole.position.copy(position);
            
            // Gravity field
            const gravityField = new THREE.Mesh(
                new THREE.SphereGeometry(15, 32, 32),
                new THREE.MeshBasicMaterial({
                    color: 0x0000ff,
                    transparent: true,
                    opacity: 0.1,
                    wireframe: true
                })
            );
            gravityField.position.copy(position);
            
            return { blackHole, gravityField, material };
        }

        let blackHole = null;

        // ====== BIG BANG SIMULATION ====== //
        function triggerBigBang() {
            const particles = 10000;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];
            
            for (let i = 0; i < particles; i++) {
                // Random spherical distribution
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const radius = 0.1;
                
                positions.push(
                    radius * Math.sin(phi) * Math.cos(theta),
                    radius * Math.sin(phi) * Math.sin(theta),
                    radius * Math.cos(phi)
                );
                
                // Color based on particle type
                const type = Math.random();
                if (type < 0.3) { // Hydrogen (blue)
                    colors.push(0.3, 0.5, 1.0);
                } else if (type < 0.6) { // Helium (white)
                    colors.push(1.0, 1.0, 1.0);
                } else { // Cosmic dust (yellow/orange)
                    colors.push(1.0, 0.8, 0.3);
                }
                
                sizes.push(Math.random() * 0.5);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            
            const material = new THREE.PointsMaterial({
                size: 0.05,
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });
            
            const bigBang = new THREE.Points(geometry, material);
            scene.add(bigBang);
            
            // Animate expansion
            const startTime = Date.now();
            const duration = 5000; // 5 seconds
            
            function animateExpansion() {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / duration;
                
                if (progress < 1) {
                    const positions = bigBang.geometry.attributes.position.array;
                    const expansionFactor = progress * 500;
                    
                    for (let i = 0; i < positions.length; i += 3) {
                        const x = positions[i];
                        const y = positions[i + 1];
                        const z = positions[i + 2];
                        
                        const direction = new THREE.Vector3(x, y, z).normalize();
                        const speed = 0.5 + Math.random() * 2;
                        
                        positions[i] = x + direction.x * speed * expansionFactor;
                        positions[i + 1] = y + direction.y * speed * expansionFactor;
                        positions[i + 2] = z + direction.z * speed * expansionFactor;
                    }
                    
                    bigBang.geometry.attributes.position.needsUpdate = true;
                    requestAnimationFrame(animateExpansion);
                }
            }
            
            animateExpansion();
        }

        // ====== CAMERA & CONTROLS ====== //
        camera.position.set(0, 50, 100);
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 10;
        controls.maxDistance = 1000;

        // ====== UI CONTROLS ====== //
        document.getElementById('bigBang').addEventListener('click', triggerBigBang);
        document.getElementById('blackHole').addEventListener('click', () => {
            if (blackHole) scene.remove(blackHole.blackHole, blackHole.gravityField);
            blackHole = createBlackHole(new THREE.Vector3(
                Math.random() * 50 - 25,
                Math.random() * 10 - 5,
                Math.random() * 50 - 25
            ));
            scene.add(blackHole.blackHole, blackHole.gravityField);
        });
        
        let isExpanding = false;
        document.getElementById('expand').addEventListener('click', () => {
            isExpanding = !isExpanding;
        });

        // ====== ANIMATION LOOP ====== //
        function animate() {
            requestAnimationFrame(animate);
            
            // Rotate planets
            sun.planet.rotation.y += 0.01;
            mercury.planet.rotation.y += 0.004;
            venus.planet.rotation.y += 0.002;
            earth.planet.rotation.y += 0.02;
            mars.planet.rotation.y += 0.018;
            jupiter.planet.rotation.y += 0.04;
            saturn.planet.rotation.y += 0.038;
            uranus.planet.rotation.y += 0.03;
            neptune.planet.rotation.y += 0.032;
            
            // Orbit planets
            const time = Date.now() * 0.0001;
            mercury.planet.position.x = Math.cos(time * 4) * 15;
            mercury.planet.position.z = Math.sin(time * 4) * 15;
            
            venus.planet.position.x = Math.cos(time * 3) * 20;
            venus.planet.position.z = Math.sin(time * 3) * 20;
            
            earth.planet.position.x = Math.cos(time * 2) * 25;
            earth.planet.position.z = Math.sin(time * 2) * 25;
            
            mars.planet.position.x = Math.cos(time * 1.5) * 30;
            mars.planet.position.z = Math.sin(time * 1.5) * 30;
            
            jupiter.planet.position.x = Math.cos(time) * 40;
            jupiter.planet.position.z = Math.sin(time) * 40;
            
            saturn.planet.position.x = Math.cos(time * 0.9) * 50;
            saturn.planet.position.z = Math.sin(time * 0.9) * 50;
            
            uranus.planet.position.x = Math.cos(time * 0.4) * 60;
            uranus.planet.position.z = Math.sin(time * 0.4) * 60;
            
            neptune.planet.position.x = Math.cos(time * 0.1) * 70;
            neptune.planet.position.z = Math.sin(time * 0.1) * 70;
            
            // Update black hole shader
            if (blackHole) {
                blackHole.material.uniforms.time.value = time;
                
                // Simulate gravitational pull
                scene.children.forEach(obj => {
                    if (obj !== blackHole.blackHole && obj !== blackHole.gravityField && obj.position) {
                        const distance = obj.position.distanceTo(blackHole.blackHole.position);
                        if (distance < 30) {
                            const direction = new THREE.Vector3().subVectors(
                                blackHole.blackHole.position,
                                obj.position
                            ).normalize();
                            const force = 100 / (distance * distance);
                            obj.position.add(direction.multiplyScalar(force * 0.01));
                        }
                    }
                });
            }
            
            // Universe expansion
            if (isExpanding) {
                universe.scale.multiplyScalar(1.0001);
            }
            
            controls.update();
            renderer.render(scene, camera);
            
            // Update stats
            document.getElementById('stats').innerHTML = `
                Planets: 8 | Stars: ${milkyWay.geometry.attributes.position.count} |
                Camera: X:${camera.position.x.toFixed(1)}, Y:${camera.position.y.toFixed(1)}, Z:${camera.position.z.toFixed(1)}
            `;
        }
        
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
